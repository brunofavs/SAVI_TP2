
  # # Plane detection parameters
    # number_of_planes = 2 # Number of planes to detect
    # minimum_number_points = 25
    # colormap = cm.Pastel1(list(range(0,number_of_planes)))

    # print('--------- Finding planes --------- ')
    # ptcloud = deepcopy(ptCloud_downsampled)
    # planes = []
    # while True: 

    #     # Create point cloud with plane outliers for next itteration
    #     plane = PlaneDetection(ptcloud) # New plane instance
    #     ptcloud = plane.segment()       # New point cloud with outliers
    #     print(plane)

    #     # Pick Plane color
    #     idx_color = len(planes)
    #     color = colormap[idx_color, 0:3]
    #     plane.colorizeInliers(r=color[0], g=color[1], b=color[2])
    #     planes.append(plane)

    #     # Stop while loop when:
    #     if len(planes) >= number_of_planes: # stop detection planes
    #         print('Detected planes >= ' + str(number_of_planes))
    #         break
    #     elif len(ptcloud.points) < minimum_number_points:
    #         print('Number of remaining points < ' + str(minimum_number_points))
    #         break

    # ------------------------------------------
    # Table plane detector (This method uses the average height of the plane)
    # ------------------------------------------
    # print('--------- Table plane find --------- ')
    # table_plane = None
    # table_plane_mean_y = 1000
    # for plane_idx, plane in enumerate(planes):
    #     center = plane.inlier_cloud.get_center()
    #     print('Cloud ' + str(plane_idx) + ' has center ' + str(center))
    #     mean_y = center[1]

    #     if mean_y < table_plane_mean_y:
    #         table_plane = plane
    #         table_plane_mean_y = mean_y

    # table_plane.colorizeInliers(r=1, g=0, b=0) # Force plane table to be red

    # ------------------------------------------
    # Cluster extraction
    # ------------------------------------------

    # cluster_idxs = list(table_plane.inlier_cloud.cluster_dbscan(eps=0.15, min_points=25, print_progress=True))

    # # print(cluster_idxs)
    # # print(type(cluster_idxs))

    # # -1 means noise
    # possible_values = list(set(cluster_idxs))
    # if -1 in possible_values:
    #     possible_values.remove(-1)
    # print(possible_values)

    # largest_cluster_num_points = 0
    # largest_cluster_idx = None
    # for value in possible_values:
    #     num_points = cluster_idxs.count(value)
    #     if num_points > largest_cluster_num_points:
    #         largest_cluster_idx = value
    #         largest_cluster_num_points = num_points

    # largest_idxs = list(locate(cluster_idxs, lambda x: x == largest_cluster_idx))
    # table_cloud = table_plane.inlier_cloud.select_by_index(largest_idxs)
    # table_cloud.paint_uniform_color([0,1,0]) # paints the table green

    # ------------------------------------------
    # Plane Crop
    # ------------------------------------------
        
    # Create frame on the center of table plane
    # table_plane_center_xyz = table_plane.inlier_cloud.get_center()

    # T1 = np.identity(4)
    # T1[0,3] = table_plane_center_xyz[0]
    # T1[1,3] = table_plane_center_xyz[1]
    # T1[2,3] = table_plane_center_xyz[2]

    frame_plane = o3d.geometry.TriangleMesh().create_coordinate_frame(size=0.5, origin=np.array([0., 0., 0.]))
    # frame_plane = frame_plane.transform(T1)

    # # plane_ori_bounding_box = table_plane.inlier_cloud.get_axis_aligned_bounding_box()
    # # plane_ori_bounding_box.color = (1.0,0,0)

    # plane_ori_bounding_box = table_plane.inlier_cloud.get_oriented_bounding_box()
    # plane_ori_bounding_box.color = (0,1,0)
    
    # plane_bb = np.asarray(plane_ori_bounding_box.get_box_points())
